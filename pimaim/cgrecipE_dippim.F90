SUBROUTINE cgrecipE_dippim

USE commondata, ONLY: xmu,ymu,zmu, &
                      twopi,num,q,etaconst
USE boxdata, ONLY: fullhi,fourpicell,fac
USE recipdata, ONLY: kmaxx,kmaxy,kmaxz,elcall,elsall,emcall,emsall,encall, &
                     ensall,rksqmax
!---> Parallelization_S
use mpipara
!<--- Parallelization_E

IMPLICIT NONE

INTEGER :: i,l,m,n,ll,mm,nn,nmin,mmin
DOUBLE PRECISION :: rl,rkx1,rky1,rkz1,rm,rkx2,rky2, &
                 rkz2,rn,rkx3,rky3,rkz3,xkk,ckcs,ckss,cx,cy,cz,sx,sy,sz, &
                 akk,arl,arm,arn,xmumuengfac,fac2,rdotmuc,rdotmus
DOUBLE PRECISION, DIMENSION(num) :: clmall,slmall,ckcnoqall,cksnoqall,temp

!---> Parallelization_S
!mmin=0
!nmin=1
eltmp=0.d0
!<--- Parallelization_E

!---> Parallelization_S
!do ll=0,kmaxx
do ll=kmaxx_s,kmaxx_e
!<--- Parallelization_E
   l=iabs(ll)
   rl=dble(ll)*twopi

   rkx1=rl*fullhi(1,1)
   rky1=rl*fullhi(1,2)
   rkz1=rl*fullhi(1,3)

!---> Parallelization_S
!  do mm=mmin,kmaxy
   do mm=kmaxy_s(ll),kmaxy_e(ll)
!<--- Parallelization_E
      m=iabs(mm)
      rm=dble(mm)*twopi

      rkx2=rkx1+rm*fullhi(2,1)
      rky2=rky1+rm*fullhi(2,2)
      rkz2=rkz1+rm*fullhi(2,3)

      if(mm.ge.0) then
         clmall(:)=elcall(:,l)*emcall(:,m)-elsall(:,l)*emsall(:,m)
         slmall(:)=elsall(:,l)*emcall(:,m)+emsall(:,m)*elcall(:,l)
      else
         clmall(:)=elcall(:,l)*emcall(:,m)+elsall(:,l)*emsall(:,m)
         slmall(:)=elsall(:,l)*emcall(:,m)-emsall(:,m)*elcall(:,l)
      endif

!---> Parallelization_S
!     do nn=nmin,kmaxz
      do nn=kmaxz_s(mm,ll),kmaxz_e(mm,ll)
!<--- Parallelization_E
         n=iabs(nn)
         rn=dble(nn)*twopi

         rkx3=rkx2+rn*fullhi(3,1)
         rky3=rky2+rn*fullhi(3,2)
         rkz3=rkz2+rn*fullhi(3,3)

         xkk=rkx3*rkx3+rky3*rky3+rkz3*rkz3

         if(xkk.le.rksqmax) then

            if(nn.ge.0) then
               ckcnoqall(:)=clmall(:)*encall(:,n)-slmall(:)*ensall(:,n)
               cksnoqall(:)=slmall(:)*encall(:,n)+clmall(:)*ensall(:,n)
            else
               ckcnoqall(:)=clmall(:)*encall(:,n)+slmall(:)*ensall(:,n)
               cksnoqall(:)=slmall(:)*encall(:,n)-clmall(:)*ensall(:,n)
            endif

            ckcs=SUM(ckcnoqall*q)
            ckss=SUM(cksnoqall*q)

            cx=SUM(ckcnoqall*xmu)
            cy=SUM(ckcnoqall*ymu)
            cz=SUM(ckcnoqall*zmu)

            sx=SUM(cksnoqall*xmu)
            sy=SUM(cksnoqall*ymu)
            sz=SUM(cksnoqall*zmu)

            akk=exp(etaconst*xkk)/xkk

            arl=akk*rkx3
            arm=akk*rky3
            arn=akk*rkz3

            rdotmuc=rkx3*cx+rky3*cy+rkz3*cz
            rdotmus=rkx3*sx+rky3*sy+rkz3*sz
!
! this is the qTmu term:
! force and electric field due to dipoles:
!
            temp=-ckcnoqall*rdotmuc-cksnoqall*rdotmus

!---> Parallelization_S
!           elecx=elecx+arl*temp
!           elecy=elecy+arm*temp
!           elecz=elecz+arn*temp
            eltmp(1:num)=eltmp(1:num)+arl*temp
            eltmp(num+1:2*num)=eltmp(num+1:2*num)+arm*temp
            eltmp(2*num+1:3*num)=eltmp(2*num+1:3*num)+arn*temp
         endif
      enddo   
!---> Parallelization_S
!     nmin=-kmaxz
!<--- Parallelization_E
   enddo   
!---> Parallelization_S
!  mmin=-kmaxy
!<--- Parallelization_E
enddo   
!---> Parallelization_S
!........fac is 2 times fourpicell (two forces from differentiating double sum)
eltmp=eltmp*fac

return
END SUBROUTINE
